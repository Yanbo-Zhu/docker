
# 1 注意点

容器卷记得加入
·	--privileged=true
 
 Docker挂载主机目录访问如果出现cannot open directory .: Permission denied
解决办法：在挂载目录后多加一个--privileged=true参数即可
  
如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，
在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用--privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即
使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。


例子
![](image/Pasted%20image%2020240208123521.png)

-v 宿主机的绝对路径: 容器内的路径   把主机的路径 映射到 容器内 

# 2 什么是 容器卷 
卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：
卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷

![](image/Pasted%20image%2020240208123825.png)
 
·	一句话：有点类似我们Redis里面的rdb和aof文件
·	<mark>将docker容器内的数据保存进宿主机的磁盘中</mark>
·	运行一个带有容器卷存储功能的容器实例
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名


将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的 
Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。
为了能保存数据在docker中我们使用卷。
 
特点：
1：数据卷可在容器之间共享或重用数据
2：卷中的更改可以直接实时生效，爽
3：数据卷中的更改不会包含在镜像的更新中
4：数据卷的生命周期一直持续到没有容器使用它为止



# 3 宿主和容器之间映射添加容器卷#

公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash
docker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名


查看数据卷是否挂载成功
docker inspect 容器ID

![](image/Pasted%20image%2020240208124949.png)

·	容器和宿主机之间数据共享
1 docker修改，主机同步获得 
2 主机修改，docker同步获得
3 docker容器stop，主机修改，docker容器重启看数据是否同步。

![](image/Pasted%20image%2020240208125036.png)



# 4 读写规则映射添加说明

读写(默认)
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw      镜像名
·	默认同上案例，默认就是rw
![](image/Pasted%20image%2020240208125233.png)

 rw = read + write
![](image/Pasted%20image%2020240208125246.png)


![](image/Pasted%20image%2020240208125310.png)


只读 ro 
容器实例内部被限制，只能读取不能写
/容器目录:ro 镜像名       就能完成功能，此时容器自己只能读取不能写  
ro = read only
docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro      镜像名
此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。

# 5 卷的继承和共享

容器1完成和宿主机的映射
docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu


容器2继承容器1的卷规则  (--volumes from u1)
·	docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu
![](image/Pasted%20image%2020240208125452.png)

如果 u1 没有了.   u2 中的挂在 依然存在.  
u1 和 u2 两个是独立的 






