
# 1 注意点

docker run -v xx宿主机的目录:yy容器内的目录  

容器卷记得加入
·	--privileged=true
 
 Docker挂载主机目录访问如果出现cannot open directory .: Permission denied
解决办法：在挂载目录后多加一个--privileged=true参数即可
  
如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，
在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用--privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即
使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。


例子
![](image/Pasted%20image%2020240208123521.png)

-v 宿主机的绝对路径: 容器内的路径   把主机的路径 映射到 容器内 

# 2 什么是 容器卷 
卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：
卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷

![](image/Pasted%20image%2020240208123825.png)
 
·	一句话：有点类似我们Redis里面的rdb和aof文件
·	<mark>将docker容器内的数据保存进宿主机的磁盘中</mark>
·	运行一个带有容器卷存储功能的容器实例
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名


将运用与运行的环境打包镜像，run后形成容器实例运行 ，但是我们对数据的要求希望是持久化的 
Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。
为了能保存数据在docker中我们使用卷。
 
特点：
1：数据卷可在容器之间共享或重用数据
2：卷中的更改可以直接实时生效，爽
3：数据卷中的更改不会包含在镜像的更新中
4：数据卷的生命周期一直持续到没有容器使用它为止



# 3 宿主和容器之间映射添加容器卷

公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash
docker run -it --name myu3 --privileged=true -v /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录      镜像名


查看数据卷是否挂载成功
docker inspect 容器ID

![](image/Pasted%20image%2020240208124949.png)

·	容器和宿主机之间数据共享
1 docker修改，主机同步获得 
2 主机修改，docker同步获得
3 docker容器stop，主机修改，docker容器重启看数据是否同步。

![](image/Pasted%20image%2020240208125036.png)


# 4 挂载模式 

所有 docker volume, 在没有指定 host机 的目录的情况下,  默认都是把 "/var/lib/docker/volumes/<自定义的volumn名字>/\_data" 和 <自己指定的 容器内目录> 之间 项目 关联 

## 4.1 匿名挂载
docker run -it -v /容器内目录 ubuntu /bin/bash
不写宿主机目录 , 没有指定目录
所有 docker volume, 在没有指定 host机 的目录的情况下,  默认都是把 "/var/lib/docker/volumes/<自定义的volumn名字>/\_data" 和 <自己指定的 <容器内目录> 之间 项目 关联 
效果 不是把 当前宿主机 目录 . 和  <容器内目录>  挂在一起了

docker volume ls 中可以看出 这个 volume 没有名字 
![](image/Pasted%20image%2020240210135438.png)

## 4.2 具名挂载

docker run -it -v 自定义的volumn的名字:/容器内目录 ubuntu /bin/bash
不写宿主机目录 , 没有指定目录, 因为 这里给的不是 `-v /宿主机目录:/容器内目录` 没给 一个/
所有 docker volume, 在没有指定 host机 的目录的情况下,  默认都是把 "/var/lib/docker/volumes/<自定义的volumn名字>/\_data" 和 <自己指定的 容器内目录> 之间 项目 关联 
效果 不是把 当前宿主机 目录 . 和  <容器内目录>  挂在一起了
这个volume 的名字就是 给出的 自定义的volumn的名字, 这个volumen 不一定非要 之前就已经存在了

![](image/Pasted%20image%2020240210135855.png)

## 4.3 指定路径挂载

公式：docker run -it -v /宿主机目录:/容器内目录 ubuntu /bin/bash

效果 是把  给定的 <宿主机目录>  和  <容器内目录>  挂在一起了


# 5 docker volume

![](image/Pasted%20image%2020240210134544.png)


# 6 读写规则映射添加说明

读写(默认)
·	 docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw      镜像名
·	默认同上案例，默认就是rw
![](image/Pasted%20image%2020240208125233.png)

 rw = read + write
![](image/Pasted%20image%2020240208125246.png)


![](image/Pasted%20image%2020240208125310.png)


只读 ro 
容器实例内部被限制，只能读取不能写
/容器目录:ro 镜像名       就能完成功能，此时容器自己只能读取不能写  
ro = read only
docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro      镜像名
此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。

# 7 卷的继承和共享

容器之间的配置信息的传递, 数据卷容器的生命周期一直持续到没有容器使用为止
但是你一旦持久化到了本地, 这时候本地的数据是不会消失的 

容器1完成和宿主机的映射
docker run -it  --privileged=true -v /mydocker/u:/tmp --name u1 ubuntu


容器2继承容器1的卷规则  (--volumes from u1)
·	docker run -it  --privileged=true --volumes-from <父类容器的名称, 或者 这个容器的id>  --name u2 ubuntu
![](image/Pasted%20image%2020240208125452.png)

如果 contianer u1 没有了 被删除, 或者被停止了.   u2 中的挂载的volume 依然存在., 虽然  这个volumen 是 build 生成 container u1 的时候 一起生成的 随机的 volume
u1 和 u2 两个是独立的 
只要还有一个 容器还在使用这个 volume,  这个volume 就还存在 
如果没有一个 容器还在使用这个volume 了, 则这个volume 就自动消失了. 

![](image/Pasted%20image%2020240210145043.png)








