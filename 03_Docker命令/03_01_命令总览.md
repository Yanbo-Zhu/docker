
# 1 总览

![](image/Pasted%20image%2020240207171537.png)


attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像

build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像

commit    Create a new image from a container changes   # 提交当前容器为新的镜像

cp        Copy files/folders from the containers filesystem to the host path   `#从容器中拷贝指定文件或者目录到宿主机中`

create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器

diff      Inspect changes on a container's filesystem   # 查看 docker 容器变化

events    Get real time events from the server          # 从 docker 服务获取容器实时事件

exec      Run a command in an existing container        # 在已存在的容器上运行命令

export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件`[对应 import ]`

history   Show the history of an image                  # 展示一个镜像形成历史

images    List images                                   # 列出系统当前镜像

import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像`[对应export]`

info      Display system-wide information               # 显示系统相关信息

inspect   Return low-level information on a container   # 查看容器详细信息

kill      Kill a running container                      # kill 指定 docker 容器

load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像`[对应 save]`

login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器

logout    Log out from a Docker registry server          # 从当前 Docker registry 退出

logs      Fetch the logs of a container                 # 输出当前容器日志信息

port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口

pause     Pause all processes within a container        # 暂停容器

ps        List containers                               # 列出容器列表

pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像

push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器

restart   Restart a running container                   # 重启运行的容器

rm        Remove one or more containers                 # 移除一个或者多个容器

rmi       Remove one or more images       # 移除一个或多个镜像`[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]`

run       Run a command in a new container              # 创建一个新的容器并运行一个命令

save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包`[对应 load]`

search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像

start     Start a stopped containers                    # 启动容器

stop      Stop a running containers                     # 停止容器

tag       Tag an image into a repository                # 给源中镜像打标签

top       Lookup the running processes of a container   # 查看容器中运行的进程信息

unpause   Unpause a paused container                    # 取消暂停容器

version   Show the docker version information           # 查看 docker 版本号

wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值


|   |   |
|---|---|
|Command|Description|
|docker container attach|Attach local standard input, output, and error streams to a running container|
|docker container commit|Create a new image from a container’s changes|
|docker container cp|Copy files/folders between a container and the local filesystem|
|docker container create|Create a new container|
|docker container diff|Inspect changes to files or directories on a container’s filesystem|
|docker container exec|Run a command in a running container|
|docker container export|Export a container’s filesystem as a tar archive|
|docker container inspect|Display detailed information on one or more containers|
|docker container kill|Kill one or more running containers|
|docker container logs|Fetch the logs of a container|
|docker container ls|List containers|
|docker container pause|Pause all processes within one or more containers|
|docker container port|List port mappings or a specific mapping for the container|
|docker container prune|Remove all stopped containers|
|docker container rename|Rename a container|
|docker container restart|Restart one or more containers|
|docker container rm|Remove one or more containers|
|docker container run|Run a command in a new container|
|docker container start|Start one or more stopped containers|
|docker container stats|Display a live stream of container(s) resource usage statistics|
|docker container stop|Stop one or more running containers|
|docker container top|Display the running processes of a container|
|docker container unpause|Unpause all processes within one or more containers|
|docker container update|Update configuration of one or more containers|
|docker container wait|Block until one or more containers stop, then print their exit codes|


# 2 预设值 

Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（官方文档）。
$ sudo usermod -aG docker $USER


# 3 维护 

## 3.1 Docker scan 
use "docker scan" to run Snyk tests against images to find vulnerabilities and learn how to fix this 
![](image/Pasted%20image%2020240208105736.png)


## 3.2 Docker prune 
Host system aufräumen 

![](image/Pasted%20image%2020240208105750.png)

docker image prune: 只删除虚悬镜像 
使用docker image prune无法删除的，可以使用docker ps -a查找并删除使用该镜像的容器，然后在使用docker image prune删除虚悬镜像
docker image prune -a 清理无容器使用的镜像

所有镜像都删除，包括虚悬镜像。所有的 docker system prune -a

![](image/Pasted%20image%2020240208105754.png)

## 3.3 docker system 

![](image/Pasted%20image%2020240208105806.png)




# 4 docker network 

![](image/Pasted%20image%2020240208105926.png)


## 4.1 Docker network create 

在安装Docker Engine时会自动创建一个默认的bridge网络docker0。
此外，还可以创建自己的bridge网络或overlay网络。

bridge网络依附于运行Docker Engine的单台主机上，而overlay网络能够覆盖运行各自Docker Engine的多主机环境中。

创建bridge网络：
不指定网络驱动时默认创建的bridge网络
 docker network create simple-network
查看网络内部信息
 docker network inspect simple-network
应用到容器时，可进入容器内部使用ifconfig查看容器的网络详情


但是创建一个overlay网络
就需要一些前提条件（具体操作请参考Docker容器网络相关内容）：
- key-value store（Engine支持Consul、Etcd和ZooKeeper等分布式存储的key-value store）
- 集群中所有主机已经连接到key-value store
- swarm集群中每个主机都配置了下面的daemon参数
- –cluster-store
- –cluster-store-opt
- –cluster-advertise


然后创建overlay网络：
创建网络时，使用参数`-d`指定驱动类型为overlay
docker network create -d overlay my-multihost-network
就使用--subnet选项创建子网而言，bridge网络只能指定一个子网，而overlay网络支持多个子网。

在bridge和overlay网络驱动下创建的网络可以指定不同的参数，具体请参考：https://docs.docker.com/engine/userguide/networking/work-with-networks/


# 5 帮助启动类命令

·	启动docker： systemctl start docker
·	停止docker： systemctl stop docker
·	重启docker： systemctl restart docker
·	查看docker状态： systemctl status docker
·	开机启动： systemctl enable docker
·	查看docker概要信息： docker info
·	查看docker总体帮助文档： docker --help
·	查看docker命令帮助文档： docker 具体命令 --help
 docker version: docker -v



# 6 	镜像命令

## 6.1 docker images / docker image ls 列出本地主机上的镜像

![](image/Pasted%20image%2020240207164503.png)

各个选项说明:
REPOSITORY：表示镜像的仓库源
TAG：镜像的标签版本号
IMAGE ID：镜像ID
CREATED：镜像创建时间
SIZE：镜像大小

 同一仓库源可以有多个 TAG版本，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。
如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像
 
 
·	OPTIONS说明：
·	-a :列出本地所有的镜像（含历史映像层）
·	-q :只显示镜像ID。
--digests 显示镜像的摘要信息
--no-trunc 显示完整的镜像信息


## 6.2 docker search 某个XXX镜像名字

docker search [OPTIONS] 镜像名字
![](image/Pasted%20image%2020240207164546.png)

OPTIONS说明：
·	--limit : 只列出N个镜像，默认25个
·	docker search --limit 5 redis

![](image/Pasted%20image%2020240207164610.png)

## 6.3 docker pull 某个XXX镜像名字

·	下载镜像
·	docker pull 镜像名字[:TAG]
·	docker pull 镜像名字
·	没有TAG就是最新版
·	等价于
·	docker pull 镜像名字:latest

docker pull ubuntu

![](image/Pasted%20image%2020240207164655.png)

## 6.4 docker tag 

可以用来个 image 改个名字 

先docker tag imageid username/repository:tagname 再docker push username/repository:tagname
docker tag 自己登录用户名/镜像名:tag 再push

## 6.5 docker push 


最后，发布 image 文件。
 $ docker image push [username]/[repository]:[tag] 

docker push 后面家的 image名字:版本号， 这两个信息一定都要是本地image已经存在的。 
必须要带上版本号， 必须得加 username/repository 、 
其实 repository的名字 就是 自己给这个image 起的名字。 但是这个 repo 要存很多这个image 的不同版本 所以就变成了仓库 
push 的时候也是按照 image 里面的层级一层层push 的

![](image/Pasted%20image%2020240213123745.png)

![](image/Pasted%20image%2020240213123620.png)

## 6.6 docker system df 查看镜像/容器/数据卷所占的空间

![](image/Pasted%20image%2020240207164710.png)

## 6.7 docker rmi 某个XXX镜像名字ID  删除

·	删除镜像
·	删除单个
·	docker rmi  -f 镜像ID
·	删除多个
·	docker rmi -f 镜像名1:TAG 镜像名2:TAG
·	删除全部
·	docker rmi -f $(docker images -qa)


## 6.8 docker build 
`docker build  [options] PATH|URL`

这个命令 是用来生成 一个 docker image 的
The docker build command builds Docker images from a Dockerfile and a “context”. 
A build’s context is the set of files located in the specified PATH or URL. 
The build process can refer to any of the files in the context. For example, your build can use a COPY instruction to reference a file in the context.

Docker Build 出来的 image 都到了哪里去了 : 
[https://stackoverflow.com/questions/42250222/where-is-docker-image-location-in-windows-10](https://stackoverflow.com/questions/42250222/where-is-docker-image-location-in-windows-10)


option
--build-arg，设置构建时的环境变量
--no-cache，默认false。设置该选项，将不使用Build Cache构建镜像
--pull，默认false。设置该选项，总是尝试pull镜像的最新版本
--compress，默认false。设置该选项，将使用gzip压缩构建的上下文
--file, -f，Dockerfile的完整路径，默认值为‘PATH/Dockerfile’
--label，为生成的镜像设置metadata
--tag, -t，镜像的名字及tag，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个tag
--network，默认default。设置该选项，Set the networking mode for the RUN instructions during build

	PATH | URL 
给出命令执行的上下文（位于指定 PATH 或 URL 中的一组文件）。上下文可以是构建执行所在的本地路径PATH，也可以是远程URL，如Git库、文本文件等。在 dockerfile 中写的文件路径都会以这个上下文开始找。



## 6.9 例子: 
docker build -f Dockerfile-el8 -t rpm-builder-8 . 

上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。
 最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。

生成的 image 就放在了当前目录下 

|   |   |
|---|---|
|.<br><br>Build with PATH|docker build .<br><br>将当前目录的所有文件 都 打包这个 一个 docker image<br><br>This example specifies that the PATH is ., and so all the files in the local directory get tard and sent to the Docker daemon.<br><br>The PATH specifies where to find the files for the “context” of the build on the Docker daemon.<br><br>Remember that the daemon could be running on a remote machine and that no parsing of the Dockerfile happens at the client side (where you’re running docker build). That means that all the files at PATH get sent, not just the ones listed to ADD in the Dockerfile.|
|Tag an image (-t, --tag)|给这个 生成的 image 起名为 rpm-builder-8<br><br> docker build -t vieux/apache:2.0 .<br><br>->  The repository name will be vieux/apache and the tag will be 2.0.|
|Specify a Dockerfile (-f, --file)|使用 那个 dockerfile|


## 6.10 docker image tag  

$ docker image tag [imageName] [username]/[repository]:[tag]

 实例
$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 



## 6.11 面试题：谈谈docker虚悬镜像是什么？

·	仓库名、标签都是`<none>`的镜像，俗称虚悬镜像dangling image

![](image/Pasted%20image%2020240207164940.png)


# 7 容器命令

有镜像才能创建容器， 这是根本前提(下载一个CentOS或者ubuntu镜像演示)


## 7.1 Docker create  新建一个容器 但是不启用它

docker create ：创建一个新的容器但不启动它

用法同 docker run

语法
`docker create [OPTIONS] IMAGE [COMMAND] [ARG...]`
语法同 docker run

实例
使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob

runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      
09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f 

## 7.2 docker run 新建+启动容器
`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`



### 7.2.1 image 的 名字的给出 

kuangshen/vim   : tag 名字不给出的话 自动默认找最新的版本 
kuangshen/bim:1.0, 找 image 的1.0 version 

### 7.2.2 OPTIONS说明（常用）
 有些是一个减号，有些是两个减号
 
--name="容器新名字"       为容器指定一个名称；
--detach , -d	  : 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；
-i：以交互模式运行容器，通常与 -t 同时使用；
-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；
也即启动交互式容器(前台有伪终端，等待交互)；
-P: 随机端口映射，大写P
![](image/Pasted%20image%2020240208142200.png)
外部的主机port 32768 映射到 docker 的端口 32768 , 就是说 如果要从外部访问, 就放到 32768 等于访问 8080

--publish , -p	 : 指定端口映射，小写p
![](image/Pasted%20image%2020240207165827.png)

--expose : Expose a port or a range of ports
--rm: Automatically remove the container when it exits , 显然，--rm 选项不能与 -d 同时使用（或者说同时使用没有意义），即只能自动清理 foreground 容器，不能自动清理detached容器。, 注意，--rm 选项也会清理容器的匿名data volumes。
--link : Add link to another container . Docker run -d -p 5601:6501 -h kibana --name kibana --link elasticsearch:elasticsearch kibana 
--hostname , -h: Container host name
--env , -e: Set environment variables   ,  docker run -e MYVAR1 --env MYVAR2=foo --env-file ./env.list ubuntu bash
![](image/Pasted%20image%2020240207173847.png)

-v Bind mount a volume 格式 -v 本地目录:容器目录  或 -v 容器目录,  docker run -it -v /宿主机目录:/容器目录 镜像名 /bin/bash
示例：
　　sudo docker run -it --rm -v $PWD(本地目录):/python(容器目录) python /bin/bash 
　　将本机的当前目录，挂载到镜像中的/python目录　　
将 当前路径 中的所有内容  挂载到 镜像中的/python 目录里面  
	python  为 image 的名称   
	/bin/bash  为 -it 的agrument , 意思为 用 bash 方法区交互他 
 
　　sudo docker run --rm -it -v /home/hyzhou/docker(本地目录):/data(容器目录) ubuntu:14.04 /bin/bash

　　将本机的/home/hyzhou/docker，挂载到镜像中的/data目录

-e, --env		Set environment variables
 ![](image/Pasted%20image%2020240210132633.png)

![](image/Pasted%20image%2020240208103832.png)


#### 7.2.2.1 /bin/sh -c

docker run -d centos /bin/sh -c "while true;do echo kuangshen;sleep 1;done"



"while true;do echo kuangshen;sleep 1;done" 是 传给 bin/sh 中 执行的脚本参数 
-c 在这里 并不是 contain run 固有的 option

![](image/Pasted%20image%2020240210131137.png)

#### 7.2.2.2 -it 5.3 启动交互式容器(前台命令行)
关系	前后对比 - 开始 启动守护式容器(后台服务器)
交互模式下，不能加-d参数。

![](image/Pasted%20image%2020240207165840.png)


使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。
docker run -it centos /bin/bash 
 
参数说明：
-i: 交互式操作。
-t: 终端。

centos : centos 镜像。
/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。
要退出终端，直接输入 exit:
执行exit会退出shell，关闭容器，如果不关闭容器，交互模式，使用docker exec命令。

#### 7.2.2.3 -d 指定容器的后台运行

在大部分的场景下，我们希望 docker 的服务是在后台运行的， 我们可以过 -d 指定容器的后台运行模式。

使用镜像centos:latest以后台模式启动一个容器 docker run -d centos, 问题：然后docker ps -a 进行查看, 会发现容器已经退出


很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.
容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。
 
这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下, 我们配置启动服务只需要启动响应的service即可。例如service nginx start
但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用, 这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.

所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行， 常见就是命令行模式，表示我还有交互操作，别中断，O(∩_∩)O哈哈~


redis 前后台启动演示case
前台交互式启动
·	 docker run -it redis:6.0.8
后台守护式启动
·	docker run -d redis:6.0.8

一般用-d后台启动的程序，再用exec进入对应容器实例
·	docker exec -it 容器ID /bin/bash
·	docker exec -it 容器ID redis-cli

#### 7.2.2.4 --volumes-from  卷的继承

docker run -it  --privileged=true --volumes-from 父类  --name u2 ubuntu

## 7.3 docker exec / attach 进入正在运行的容器并以命令行交互
1 
docker exec -it 容器ID bashShell
exec 是在容器中打开新的终端，并且可以启动新的进程 用exit退出，不会导致容器的停止。
 推荐大家使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。
 
![](image/Pasted%20image%2020240207170559.png)

![](image/Pasted%20image%2020240207170808.png)

2 
重新进入docker attach 容器ID
attach 直接进入容器启动命令的终端，不会启动新的进程 用exit退出，会导致容器的停止。
![](image/Pasted%20image%2020240207170705.png)


## 7.4 退出容器

两种退出方式
exit
·	run进去容器，exit退出，容器停止

ctrl+p+q
·	run进去容器，ctrl+p+q退出，容器不停止


## 7.5 docker container ls 

docker container ls  	show the container infos, note the ports info.   列出本机正在运行的容器
docker container ls --all 	# 列出本机所有容器，包括终止运行的容器 


## 7.6 docker rm 删除容器 

`docker rm [options] `容器ID|容器名称  容器ID|容器名称   容器ID|容器名称

删除已停止的容器
·	docker rm 容器ID
一次性删除多个容器实例
·	docker rm -f $(docker ps -a -q)
·	docker ps -a -q | xargs docker rm

-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。

![](image/Pasted%20image%2020240208103621.png)

![](image/Pasted%20image%2020240208103737.png)
## 7.7 其他

启动已停止运行的容器
·	docker start 容器ID或者容器名,   不必给 出id 的全部 ， 只要 eindeutig sein 就行
前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。

重启容器
·	docker restart 容器ID或者容器名


停止容器
·	docker stop 容器ID或者容器名
前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。
这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 


强制停止容器
·	docker kill 容器ID或容器名

# 8 docker cp

从容器内拷贝文件到主机上
·	docker cp  容器ID:容器内路径 目的主机路径
![](image/Pasted%20image%2020240207171356.png)
docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。

主机 -> 容器
docker cp   宿主机的路径  容器ID(容器名称):容器内文件或文件夹路径 

以tomcat为例
先运行一个tomcat容器，tomcat1是容器名称，访问端口8082
1）创建 /root/res目录
2）上传windows中tomcat的ROOT 和 docs目录
3）docker cp /root/res/ROOT/ 5ec80e32f738:/usr/local/tomcat/webapps
4）docker exec -it tomcat1 bash 查看文件




## 8.1 docker commit 从 某个 container 产生 新的 image  
Docker commit : Create a new image from a container changes   # 提交当前容器为新的镜像
docker commit test01 test02
NOTE: The above, test02 is a new image that I'm constructing from the test01 container.

## 8.2 docker export import 6.8 导入和导出容器

·	export 导出容器的内容留作为一个tar归档文件[对应import命令]
·	import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]

docker export 容器ID > 文件名.tar
![](image/Pasted%20image%2020240207172027.png)

cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号
![](image/Pasted%20image%2020240207172033.png)


# 9 容器命令: 维护 

## 9.1 其他 

查看容器内运行的进程
·	docker top 容器ID
查看容器内部细节
·	docker inspect 容器ID


docker port only displays current forwardings.
- docker port 



## 9.2 docker ps 列出当前所有正在运行的容器

OPTIONS说明（常用）：
 
-a : 列出当前所有正在运行的容器+历史上运行过的 和未运行的容器的ID
-l :  显示最近创建的容器。
-n：显示最近n个创建的容器。
-q :静默模式，只显示容器编号。

![](image/Pasted%20image%2020240207215527.png)

## 9.3 docker logs 容器ID  / 查看容器日志


查看容器日志
·	docker logs 容器ID

![](image/Pasted%20image%2020240207215546.png)


Option	Default	Description
--details		Show extra details provided to logs
-f, --follow		Follow log output  保留打印窗口 
--since		Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
-n, --tail	all	Number of lines to show from the end of the logs
-t, --timestamps		Show timestamps
--until		API 1.35+ Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)

